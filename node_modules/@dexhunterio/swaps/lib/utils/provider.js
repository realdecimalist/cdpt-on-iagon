import { jsx as E } from "react/jsx-runtime";
import * as K from "react";
import J from "react";
import { a as X, i as Y, r as Z, n as q, t as $, g as tt, e as N, d as v, b as U, c as B, S as L, h as V, j as S, m as I, k as H, f as G, o as _, p as Q, l as et, q as A, u as j } from "../notifyManager-b5b16d35.js";
import { u as st, Q as it } from "../QueryClientProvider-103c6f38.js";
const T = console;
class W {
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout(), X(this.cacheTime) && (this.gcTimeout = setTimeout(() => {
      this.optionalRemove();
    }, this.cacheTime));
  }
  updateCacheTime(t) {
    this.cacheTime = Math.max(this.cacheTime || 0, t ?? (Y ? 1 / 0 : 5 * 60 * 1e3));
  }
  clearGcTimeout() {
    this.gcTimeout && (clearTimeout(this.gcTimeout), this.gcTimeout = void 0);
  }
}
class rt extends W {
  constructor(t) {
    super(), this.abortSignalConsumed = !1, this.defaultOptions = t.defaultOptions, this.setOptions(t.options), this.observers = [], this.cache = t.cache, this.logger = t.logger || T, this.queryKey = t.queryKey, this.queryHash = t.queryHash, this.initialState = t.state || at(this.options), this.state = this.initialState, this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  setOptions(t) {
    this.options = {
      ...this.defaultOptions,
      ...t
    }, this.updateCacheTime(this.options.cacheTime);
  }
  optionalRemove() {
    !this.observers.length && this.state.fetchStatus === "idle" && this.cache.remove(this);
  }
  setData(t, e) {
    const s = Z(this.state.data, t, this.options);
    return this.dispatch({
      data: s,
      type: "success",
      dataUpdatedAt: e == null ? void 0 : e.updatedAt,
      manual: e == null ? void 0 : e.manual
    }), s;
  }
  setState(t, e) {
    this.dispatch({
      type: "setState",
      state: t,
      setStateOptions: e
    });
  }
  cancel(t) {
    var e;
    const s = this.promise;
    return (e = this.retryer) == null || e.cancel(t), s ? s.then(q).catch(q) : Promise.resolve();
  }
  destroy() {
    super.destroy(), this.cancel({
      silent: !0
    });
  }
  reset() {
    this.destroy(), this.setState(this.initialState);
  }
  isActive() {
    return this.observers.some((t) => t.options.enabled !== !1);
  }
  isDisabled() {
    return this.getObserversCount() > 0 && !this.isActive();
  }
  isStale() {
    return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some((t) => t.getCurrentResult().isStale);
  }
  isStaleByTime(t = 0) {
    return this.state.isInvalidated || !this.state.dataUpdatedAt || !$(this.state.dataUpdatedAt, t);
  }
  onFocus() {
    var t;
    const e = this.observers.find((s) => s.shouldFetchOnWindowFocus());
    e && e.refetch({
      cancelRefetch: !1
    }), (t = this.retryer) == null || t.continue();
  }
  onOnline() {
    var t;
    const e = this.observers.find((s) => s.shouldFetchOnReconnect());
    e && e.refetch({
      cancelRefetch: !1
    }), (t = this.retryer) == null || t.continue();
  }
  addObserver(t) {
    this.observers.includes(t) || (this.observers.push(t), this.clearGcTimeout(), this.cache.notify({
      type: "observerAdded",
      query: this,
      observer: t
    }));
  }
  removeObserver(t) {
    this.observers.includes(t) && (this.observers = this.observers.filter((e) => e !== t), this.observers.length || (this.retryer && (this.abortSignalConsumed ? this.retryer.cancel({
      revert: !0
    }) : this.retryer.cancelRetry()), this.scheduleGc()), this.cache.notify({
      type: "observerRemoved",
      query: this,
      observer: t
    }));
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    this.state.isInvalidated || this.dispatch({
      type: "invalidate"
    });
  }
  fetch(t, e) {
    var s, i;
    if (this.state.fetchStatus !== "idle") {
      if (this.state.dataUpdatedAt && e != null && e.cancelRefetch)
        this.cancel({
          silent: !0
        });
      else if (this.promise) {
        var a;
        return (a = this.retryer) == null || a.continueRetry(), this.promise;
      }
    }
    if (t && this.setOptions(t), !this.options.queryFn) {
      const h = this.observers.find((y) => y.options.queryFn);
      h && this.setOptions(h.options);
    }
    const n = tt(), u = {
      queryKey: this.queryKey,
      pageParam: void 0,
      meta: this.meta
    }, o = (h) => {
      Object.defineProperty(h, "signal", {
        enumerable: !0,
        get: () => {
          if (n)
            return this.abortSignalConsumed = !0, n.signal;
        }
      });
    };
    o(u);
    const p = () => this.options.queryFn ? (this.abortSignalConsumed = !1, this.options.queryFn(u)) : Promise.reject("Missing queryFn for queryKey '" + this.options.queryHash + "'"), m = {
      fetchOptions: e,
      options: this.options,
      queryKey: this.queryKey,
      state: this.state,
      fetchFn: p
    };
    if (o(m), (s = this.options.behavior) == null || s.onFetch(m), this.revertState = this.state, this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((i = m.fetchOptions) == null ? void 0 : i.meta)) {
      var b;
      this.dispatch({
        type: "fetch",
        meta: (b = m.fetchOptions) == null ? void 0 : b.meta
      });
    }
    const f = (h) => {
      if (U(h) && h.silent || this.dispatch({
        type: "error",
        error: h
      }), !U(h)) {
        var y, g, C, O;
        (y = (g = this.cache.config).onError) == null || y.call(g, h, this), (C = (O = this.cache.config).onSettled) == null || C.call(O, this.state.data, h, this);
      }
      this.isFetchingOptimistic || this.scheduleGc(), this.isFetchingOptimistic = !1;
    };
    return this.retryer = N({
      fn: m.fetchFn,
      abort: n == null ? void 0 : n.abort.bind(n),
      onSuccess: (h) => {
        var y, g, C, O;
        if (typeof h > "u") {
          f(new Error(this.queryHash + " data is undefined"));
          return;
        }
        this.setData(h), (y = (g = this.cache.config).onSuccess) == null || y.call(g, h, this), (C = (O = this.cache.config).onSettled) == null || C.call(O, h, this.state.error, this), this.isFetchingOptimistic || this.scheduleGc(), this.isFetchingOptimistic = !1;
      },
      onError: f,
      onFail: (h, y) => {
        this.dispatch({
          type: "failed",
          failureCount: h,
          error: y
        });
      },
      onPause: () => {
        this.dispatch({
          type: "pause"
        });
      },
      onContinue: () => {
        this.dispatch({
          type: "continue"
        });
      },
      retry: m.options.retry,
      retryDelay: m.options.retryDelay,
      networkMode: m.options.networkMode
    }), this.promise = this.retryer.promise, this.promise;
  }
  dispatch(t) {
    const e = (s) => {
      var i, a;
      switch (t.type) {
        case "failed":
          return {
            ...s,
            fetchFailureCount: t.failureCount,
            fetchFailureReason: t.error
          };
        case "pause":
          return {
            ...s,
            fetchStatus: "paused"
          };
        case "continue":
          return {
            ...s,
            fetchStatus: "fetching"
          };
        case "fetch":
          return {
            ...s,
            fetchFailureCount: 0,
            fetchFailureReason: null,
            fetchMeta: (i = t.meta) != null ? i : null,
            fetchStatus: B(this.options.networkMode) ? "fetching" : "paused",
            ...!s.dataUpdatedAt && {
              error: null,
              status: "loading"
            }
          };
        case "success":
          return {
            ...s,
            data: t.data,
            dataUpdateCount: s.dataUpdateCount + 1,
            dataUpdatedAt: (a = t.dataUpdatedAt) != null ? a : Date.now(),
            error: null,
            isInvalidated: !1,
            status: "success",
            ...!t.manual && {
              fetchStatus: "idle",
              fetchFailureCount: 0,
              fetchFailureReason: null
            }
          };
        case "error":
          const n = t.error;
          return U(n) && n.revert && this.revertState ? {
            ...this.revertState,
            fetchStatus: "idle"
          } : {
            ...s,
            error: n,
            errorUpdateCount: s.errorUpdateCount + 1,
            errorUpdatedAt: Date.now(),
            fetchFailureCount: s.fetchFailureCount + 1,
            fetchFailureReason: n,
            fetchStatus: "idle",
            status: "error"
          };
        case "invalidate":
          return {
            ...s,
            isInvalidated: !0
          };
        case "setState":
          return {
            ...s,
            ...t.state
          };
      }
    };
    this.state = e(this.state), v.batch(() => {
      this.observers.forEach((s) => {
        s.onQueryUpdate(t);
      }), this.cache.notify({
        query: this,
        type: "updated",
        action: t
      });
    });
  }
}
function at(r) {
  const t = typeof r.initialData == "function" ? r.initialData() : r.initialData, e = typeof t < "u", s = e ? typeof r.initialDataUpdatedAt == "function" ? r.initialDataUpdatedAt() : r.initialDataUpdatedAt : 0;
  return {
    data: t,
    dataUpdateCount: 0,
    dataUpdatedAt: e ? s ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: e ? "success" : "loading",
    fetchStatus: "idle"
  };
}
class nt extends L {
  constructor(t) {
    super(), this.config = t || {}, this.queries = [], this.queriesMap = {};
  }
  build(t, e, s) {
    var i;
    const a = e.queryKey, n = (i = e.queryHash) != null ? i : V(a, e);
    let u = this.get(n);
    return u || (u = new rt({
      cache: this,
      logger: t.getLogger(),
      queryKey: a,
      queryHash: n,
      options: t.defaultQueryOptions(e),
      state: s,
      defaultOptions: t.getQueryDefaults(a)
    }), this.add(u)), u;
  }
  add(t) {
    this.queriesMap[t.queryHash] || (this.queriesMap[t.queryHash] = t, this.queries.push(t), this.notify({
      type: "added",
      query: t
    }));
  }
  remove(t) {
    const e = this.queriesMap[t.queryHash];
    e && (t.destroy(), this.queries = this.queries.filter((s) => s !== t), e === t && delete this.queriesMap[t.queryHash], this.notify({
      type: "removed",
      query: t
    }));
  }
  clear() {
    v.batch(() => {
      this.queries.forEach((t) => {
        this.remove(t);
      });
    });
  }
  get(t) {
    return this.queriesMap[t];
  }
  getAll() {
    return this.queries;
  }
  find(t, e) {
    const [s] = S(t, e);
    return typeof s.exact > "u" && (s.exact = !0), this.queries.find((i) => I(s, i));
  }
  findAll(t, e) {
    const [s] = S(t, e);
    return Object.keys(s).length > 0 ? this.queries.filter((i) => I(s, i)) : this.queries;
  }
  notify(t) {
    v.batch(() => {
      this.listeners.forEach(({
        listener: e
      }) => {
        e(t);
      });
    });
  }
  onFocus() {
    v.batch(() => {
      this.queries.forEach((t) => {
        t.onFocus();
      });
    });
  }
  onOnline() {
    v.batch(() => {
      this.queries.forEach((t) => {
        t.onOnline();
      });
    });
  }
}
class ut extends W {
  constructor(t) {
    super(), this.defaultOptions = t.defaultOptions, this.mutationId = t.mutationId, this.mutationCache = t.mutationCache, this.logger = t.logger || T, this.observers = [], this.state = t.state || ot(), this.setOptions(t.options), this.scheduleGc();
  }
  setOptions(t) {
    this.options = {
      ...this.defaultOptions,
      ...t
    }, this.updateCacheTime(this.options.cacheTime);
  }
  get meta() {
    return this.options.meta;
  }
  setState(t) {
    this.dispatch({
      type: "setState",
      state: t
    });
  }
  addObserver(t) {
    this.observers.includes(t) || (this.observers.push(t), this.clearGcTimeout(), this.mutationCache.notify({
      type: "observerAdded",
      mutation: this,
      observer: t
    }));
  }
  removeObserver(t) {
    this.observers = this.observers.filter((e) => e !== t), this.scheduleGc(), this.mutationCache.notify({
      type: "observerRemoved",
      mutation: this,
      observer: t
    });
  }
  optionalRemove() {
    this.observers.length || (this.state.status === "loading" ? this.scheduleGc() : this.mutationCache.remove(this));
  }
  continue() {
    var t, e;
    return (t = (e = this.retryer) == null ? void 0 : e.continue()) != null ? t : this.execute();
  }
  async execute() {
    const t = () => {
      var l;
      return this.retryer = N({
        fn: () => this.options.mutationFn ? this.options.mutationFn(this.state.variables) : Promise.reject("No mutationFn found"),
        onFail: (d, F) => {
          this.dispatch({
            type: "failed",
            failureCount: d,
            error: F
          });
        },
        onPause: () => {
          this.dispatch({
            type: "pause"
          });
        },
        onContinue: () => {
          this.dispatch({
            type: "continue"
          });
        },
        retry: (l = this.options.retry) != null ? l : 0,
        retryDelay: this.options.retryDelay,
        networkMode: this.options.networkMode
      }), this.retryer.promise;
    }, e = this.state.status === "loading";
    try {
      var s, i, a, n, u, o, p, m;
      if (!e) {
        var b, f, h, y;
        this.dispatch({
          type: "loading",
          variables: this.options.variables
        }), await ((b = (f = this.mutationCache.config).onMutate) == null ? void 0 : b.call(f, this.state.variables, this));
        const d = await ((h = (y = this.options).onMutate) == null ? void 0 : h.call(y, this.state.variables));
        d !== this.state.context && this.dispatch({
          type: "loading",
          context: d,
          variables: this.state.variables
        });
      }
      const l = await t();
      return await ((s = (i = this.mutationCache.config).onSuccess) == null ? void 0 : s.call(i, l, this.state.variables, this.state.context, this)), await ((a = (n = this.options).onSuccess) == null ? void 0 : a.call(n, l, this.state.variables, this.state.context)), await ((u = (o = this.mutationCache.config).onSettled) == null ? void 0 : u.call(o, l, null, this.state.variables, this.state.context, this)), await ((p = (m = this.options).onSettled) == null ? void 0 : p.call(m, l, null, this.state.variables, this.state.context)), this.dispatch({
        type: "success",
        data: l
      }), l;
    } catch (l) {
      try {
        var g, C, O, M, D, P, w, c;
        throw await ((g = (C = this.mutationCache.config).onError) == null ? void 0 : g.call(C, l, this.state.variables, this.state.context, this)), await ((O = (M = this.options).onError) == null ? void 0 : O.call(M, l, this.state.variables, this.state.context)), await ((D = (P = this.mutationCache.config).onSettled) == null ? void 0 : D.call(P, void 0, l, this.state.variables, this.state.context, this)), await ((w = (c = this.options).onSettled) == null ? void 0 : w.call(c, void 0, l, this.state.variables, this.state.context)), l;
      } finally {
        this.dispatch({
          type: "error",
          error: l
        });
      }
    }
  }
  dispatch(t) {
    const e = (s) => {
      switch (t.type) {
        case "failed":
          return {
            ...s,
            failureCount: t.failureCount,
            failureReason: t.error
          };
        case "pause":
          return {
            ...s,
            isPaused: !0
          };
        case "continue":
          return {
            ...s,
            isPaused: !1
          };
        case "loading":
          return {
            ...s,
            context: t.context,
            data: void 0,
            failureCount: 0,
            failureReason: null,
            error: null,
            isPaused: !B(this.options.networkMode),
            status: "loading",
            variables: t.variables
          };
        case "success":
          return {
            ...s,
            data: t.data,
            failureCount: 0,
            failureReason: null,
            error: null,
            status: "success",
            isPaused: !1
          };
        case "error":
          return {
            ...s,
            data: void 0,
            error: t.error,
            failureCount: s.failureCount + 1,
            failureReason: t.error,
            isPaused: !1,
            status: "error"
          };
        case "setState":
          return {
            ...s,
            ...t.state
          };
      }
    };
    this.state = e(this.state), v.batch(() => {
      this.observers.forEach((s) => {
        s.onMutationUpdate(t);
      }), this.mutationCache.notify({
        mutation: this,
        type: "updated",
        action: t
      });
    });
  }
}
function ot() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: !1,
    status: "idle",
    variables: void 0
  };
}
class ht extends L {
  constructor(t) {
    super(), this.config = t || {}, this.mutations = [], this.mutationId = 0;
  }
  build(t, e, s) {
    const i = new ut({
      mutationCache: this,
      logger: t.getLogger(),
      mutationId: ++this.mutationId,
      options: t.defaultMutationOptions(e),
      state: s,
      defaultOptions: e.mutationKey ? t.getMutationDefaults(e.mutationKey) : void 0
    });
    return this.add(i), i;
  }
  add(t) {
    this.mutations.push(t), this.notify({
      type: "added",
      mutation: t
    });
  }
  remove(t) {
    this.mutations = this.mutations.filter((e) => e !== t), this.notify({
      type: "removed",
      mutation: t
    });
  }
  clear() {
    v.batch(() => {
      this.mutations.forEach((t) => {
        this.remove(t);
      });
    });
  }
  getAll() {
    return this.mutations;
  }
  find(t) {
    return typeof t.exact > "u" && (t.exact = !0), this.mutations.find((e) => H(t, e));
  }
  findAll(t) {
    return this.mutations.filter((e) => H(t, e));
  }
  notify(t) {
    v.batch(() => {
      this.listeners.forEach(({
        listener: e
      }) => {
        e(t);
      });
    });
  }
  resumePausedMutations() {
    var t;
    return this.resuming = ((t = this.resuming) != null ? t : Promise.resolve()).then(() => {
      const e = this.mutations.filter((s) => s.state.isPaused);
      return v.batch(() => e.reduce((s, i) => s.then(() => i.continue().catch(q)), Promise.resolve()));
    }).then(() => {
      this.resuming = void 0;
    }), this.resuming;
  }
}
function lt() {
  return {
    onFetch: (r) => {
      r.fetchFn = () => {
        var t, e, s, i, a, n;
        const u = (t = r.fetchOptions) == null || (e = t.meta) == null ? void 0 : e.refetchPage, o = (s = r.fetchOptions) == null || (i = s.meta) == null ? void 0 : i.fetchMore, p = o == null ? void 0 : o.pageParam, m = (o == null ? void 0 : o.direction) === "forward", b = (o == null ? void 0 : o.direction) === "backward", f = ((a = r.state.data) == null ? void 0 : a.pages) || [], h = ((n = r.state.data) == null ? void 0 : n.pageParams) || [];
        let y = h, g = !1;
        const C = (c) => {
          Object.defineProperty(c, "signal", {
            enumerable: !0,
            get: () => {
              var l;
              if ((l = r.signal) != null && l.aborted)
                g = !0;
              else {
                var d;
                (d = r.signal) == null || d.addEventListener("abort", () => {
                  g = !0;
                });
              }
              return r.signal;
            }
          });
        }, O = r.options.queryFn || (() => Promise.reject("Missing queryFn for queryKey '" + r.options.queryHash + "'")), M = (c, l, d, F) => (y = F ? [l, ...y] : [...y, l], F ? [d, ...c] : [...c, d]), D = (c, l, d, F) => {
          if (g)
            return Promise.reject("Cancelled");
          if (typeof d > "u" && !l && c.length)
            return Promise.resolve(c);
          const R = {
            queryKey: r.queryKey,
            pageParam: d,
            meta: r.options.meta
          };
          C(R);
          const x = O(R);
          return Promise.resolve(x).then((z) => M(c, d, z, F));
        };
        let P;
        if (!f.length)
          P = D([]);
        else if (m) {
          const c = typeof p < "u", l = c ? p : k(r.options, f);
          P = D(f, c, l);
        } else if (b) {
          const c = typeof p < "u", l = c ? p : ct(r.options, f);
          P = D(f, c, l, !0);
        } else {
          y = [];
          const c = typeof r.options.getNextPageParam > "u";
          P = (u && f[0] ? u(f[0], 0, f) : !0) ? D([], c, h[0]) : Promise.resolve(M([], h[0], f[0]));
          for (let d = 1; d < f.length; d++)
            P = P.then((F) => {
              if (u && f[d] ? u(f[d], d, f) : !0) {
                const x = c ? h[d] : k(r.options, F);
                return D(F, c, x);
              }
              return Promise.resolve(M(F, h[d], f[d]));
            });
        }
        return P.then((c) => ({
          pages: c,
          pageParams: y
        }));
      };
    }
  };
}
function k(r, t) {
  return r.getNextPageParam == null ? void 0 : r.getNextPageParam(t[t.length - 1], t);
}
function ct(r, t) {
  return r.getPreviousPageParam == null ? void 0 : r.getPreviousPageParam(t[0], t);
}
class dt {
  constructor(t = {}) {
    this.queryCache = t.queryCache || new nt(), this.mutationCache = t.mutationCache || new ht(), this.logger = t.logger || T, this.defaultOptions = t.defaultOptions || {}, this.queryDefaults = [], this.mutationDefaults = [], this.mountCount = 0;
  }
  mount() {
    this.mountCount++, this.mountCount === 1 && (this.unsubscribeFocus = G.subscribe(() => {
      G.isFocused() && (this.resumePausedMutations(), this.queryCache.onFocus());
    }), this.unsubscribeOnline = _.subscribe(() => {
      _.isOnline() && (this.resumePausedMutations(), this.queryCache.onOnline());
    }));
  }
  unmount() {
    var t, e;
    this.mountCount--, this.mountCount === 0 && ((t = this.unsubscribeFocus) == null || t.call(this), this.unsubscribeFocus = void 0, (e = this.unsubscribeOnline) == null || e.call(this), this.unsubscribeOnline = void 0);
  }
  isFetching(t, e) {
    const [s] = S(t, e);
    return s.fetchStatus = "fetching", this.queryCache.findAll(s).length;
  }
  isMutating(t) {
    return this.mutationCache.findAll({
      ...t,
      fetching: !0
    }).length;
  }
  getQueryData(t, e) {
    var s;
    return (s = this.queryCache.find(t, e)) == null ? void 0 : s.state.data;
  }
  ensureQueryData(t, e, s) {
    const i = Q(t, e, s), a = this.getQueryData(i.queryKey);
    return a ? Promise.resolve(a) : this.fetchQuery(i);
  }
  getQueriesData(t) {
    return this.getQueryCache().findAll(t).map(({
      queryKey: e,
      state: s
    }) => {
      const i = s.data;
      return [e, i];
    });
  }
  setQueryData(t, e, s) {
    const i = this.queryCache.find(t), a = i == null ? void 0 : i.state.data, n = et(e, a);
    if (typeof n > "u")
      return;
    const u = Q(t), o = this.defaultQueryOptions(u);
    return this.queryCache.build(this, o).setData(n, {
      ...s,
      manual: !0
    });
  }
  setQueriesData(t, e, s) {
    return v.batch(() => this.getQueryCache().findAll(t).map(({
      queryKey: i
    }) => [i, this.setQueryData(i, e, s)]));
  }
  getQueryState(t, e) {
    var s;
    return (s = this.queryCache.find(t, e)) == null ? void 0 : s.state;
  }
  removeQueries(t, e) {
    const [s] = S(t, e), i = this.queryCache;
    v.batch(() => {
      i.findAll(s).forEach((a) => {
        i.remove(a);
      });
    });
  }
  resetQueries(t, e, s) {
    const [i, a] = S(t, e, s), n = this.queryCache, u = {
      type: "active",
      ...i
    };
    return v.batch(() => (n.findAll(i).forEach((o) => {
      o.reset();
    }), this.refetchQueries(u, a)));
  }
  cancelQueries(t, e, s) {
    const [i, a = {}] = S(t, e, s);
    typeof a.revert > "u" && (a.revert = !0);
    const n = v.batch(() => this.queryCache.findAll(i).map((u) => u.cancel(a)));
    return Promise.all(n).then(q).catch(q);
  }
  invalidateQueries(t, e, s) {
    const [i, a] = S(t, e, s);
    return v.batch(() => {
      var n, u;
      if (this.queryCache.findAll(i).forEach((p) => {
        p.invalidate();
      }), i.refetchType === "none")
        return Promise.resolve();
      const o = {
        ...i,
        type: (n = (u = i.refetchType) != null ? u : i.type) != null ? n : "active"
      };
      return this.refetchQueries(o, a);
    });
  }
  refetchQueries(t, e, s) {
    const [i, a] = S(t, e, s), n = v.batch(() => this.queryCache.findAll(i).filter((o) => !o.isDisabled()).map((o) => {
      var p;
      return o.fetch(void 0, {
        ...a,
        cancelRefetch: (p = a == null ? void 0 : a.cancelRefetch) != null ? p : !0,
        meta: {
          refetchPage: i.refetchPage
        }
      });
    }));
    let u = Promise.all(n).then(q);
    return a != null && a.throwOnError || (u = u.catch(q)), u;
  }
  fetchQuery(t, e, s) {
    const i = Q(t, e, s), a = this.defaultQueryOptions(i);
    typeof a.retry > "u" && (a.retry = !1);
    const n = this.queryCache.build(this, a);
    return n.isStaleByTime(a.staleTime) ? n.fetch(a) : Promise.resolve(n.state.data);
  }
  prefetchQuery(t, e, s) {
    return this.fetchQuery(t, e, s).then(q).catch(q);
  }
  fetchInfiniteQuery(t, e, s) {
    const i = Q(t, e, s);
    return i.behavior = lt(), this.fetchQuery(i);
  }
  prefetchInfiniteQuery(t, e, s) {
    return this.fetchInfiniteQuery(t, e, s).then(q).catch(q);
  }
  resumePausedMutations() {
    return this.mutationCache.resumePausedMutations();
  }
  getQueryCache() {
    return this.queryCache;
  }
  getMutationCache() {
    return this.mutationCache;
  }
  getLogger() {
    return this.logger;
  }
  getDefaultOptions() {
    return this.defaultOptions;
  }
  setDefaultOptions(t) {
    this.defaultOptions = t;
  }
  setQueryDefaults(t, e) {
    const s = this.queryDefaults.find((i) => A(t) === A(i.queryKey));
    s ? s.defaultOptions = e : this.queryDefaults.push({
      queryKey: t,
      defaultOptions: e
    });
  }
  getQueryDefaults(t) {
    if (!t)
      return;
    const e = this.queryDefaults.find((s) => j(t, s.queryKey));
    return e == null ? void 0 : e.defaultOptions;
  }
  setMutationDefaults(t, e) {
    const s = this.mutationDefaults.find((i) => A(t) === A(i.mutationKey));
    s ? s.defaultOptions = e : this.mutationDefaults.push({
      mutationKey: t,
      defaultOptions: e
    });
  }
  getMutationDefaults(t) {
    if (!t)
      return;
    const e = this.mutationDefaults.find((s) => j(t, s.mutationKey));
    return e == null ? void 0 : e.defaultOptions;
  }
  defaultQueryOptions(t) {
    if (t != null && t._defaulted)
      return t;
    const e = {
      ...this.defaultOptions.queries,
      ...this.getQueryDefaults(t == null ? void 0 : t.queryKey),
      ...t,
      _defaulted: !0
    };
    return !e.queryHash && e.queryKey && (e.queryHash = V(e.queryKey, e)), typeof e.refetchOnReconnect > "u" && (e.refetchOnReconnect = e.networkMode !== "always"), typeof e.useErrorBoundary > "u" && (e.useErrorBoundary = !!e.suspense), e;
  }
  defaultMutationOptions(t) {
    return t != null && t._defaulted ? t : {
      ...this.defaultOptions.mutations,
      ...this.getMutationDefaults(t == null ? void 0 : t.mutationKey),
      ...t,
      _defaulted: !0
    };
  }
  clear() {
    this.queryCache.clear(), this.mutationCache.clear();
  }
}
function ft(r, t, e) {
  if (typeof t != "object" || t === null)
    return;
  const s = r.getMutationCache(), i = r.getQueryCache(), a = t.mutations || [], n = t.queries || [];
  a.forEach((u) => {
    var o;
    s.build(r, {
      ...e == null || (o = e.defaultOptions) == null ? void 0 : o.mutations,
      mutationKey: u.mutationKey
    }, u.state);
  }), n.forEach(({
    queryKey: u,
    state: o,
    queryHash: p
  }) => {
    var m;
    const b = i.get(p);
    if (b) {
      if (b.state.dataUpdatedAt < o.dataUpdatedAt) {
        const {
          fetchStatus: f,
          ...h
        } = o;
        b.setState(h);
      }
      return;
    }
    i.build(
      r,
      {
        ...e == null || (m = e.defaultOptions) == null ? void 0 : m.queries,
        queryKey: u,
        queryHash: p
      },
      // Reset fetch status to idle to avoid
      // query being stuck in fetching state upon hydration
      {
        ...o,
        fetchStatus: "idle"
      }
    );
  });
}
function yt(r, t = {}) {
  const e = st({
    context: t.context
  }), s = K.useRef(t);
  s.current = t, K.useMemo(() => {
    r && ft(e, r, s.current);
  }, [e, r]);
}
const pt = ({
  children: r,
  options: t,
  state: e
}) => (yt(e, t), r);
function Ct({ children: r }) {
  const [t] = J.useState(new dt());
  return /* @__PURE__ */ E(it, { client: t, children: /* @__PURE__ */ E(pt, { children: r }) });
}
export {
  Ct as default
};
