import l from "../../store/useStore.js";
import { server as A } from "../../config/axios.js";
import { roundNumber as F } from "../../utils/formatNumber.js";
import "react";
import "../../_commonjsHelpers-10dfc225.js";
import "../../index-9d43cc8b.js";
import "../../store/createTokenSearchSlice.js";
import "../../immer-548168ec.js";
import "../../store/createWalletSlice.js";
import "../../store/createSwapSettingsSlice.js";
import "../../store/createGlobalSettingsSlice.js";
import "../../store/createUserOrdersSlice.js";
import "../../store/createSwapSlice.js";
import "../../store/createChartSlice.js";
import "../../store/createBasketSlice.js";
import "../components/tokens.js";
import "../../store/createModalWhatsNewSlice.js";
import "../../store/createSwapParamsSlice.js";
import "../../index-ca8eb9e1.js";
import "../../axios-ddd885c5.js";
import "../../config/decrypt.js";
const R = () => {
  const {
    tokenSell: e,
    sellAmount: c,
    setIsTokenPriceLoading: d,
    setSwapDetails: _,
    setIsSwapDetailsLoading: i,
    setEstimationError: r,
    isTransactionLoading: f,
    swapDetails: a,
    setBuyAmount: y,
    limitPrice: g,
    limitMultiples: L
  } = l((o) => o.swapSlice), { userAddress: S, balance: w } = l((o) => o.walletSlice), h = () => {
    const o = a.total_fee + a.partner_fee, s = parseFloat(c);
    return s + o > w && (e == null ? void 0 : e.token_id) === "" ? parseFloat(s - o) : parseFloat(s);
  };
  return { estimateStopLoss: async ({ signal: o }) => {
    var p, n, m, u;
    if (f)
      return !0;
    d(!0), i(!0);
    const s = {
      user_address: S,
      token_in: e == null ? void 0 : e.token_id,
      amount: h(),
      price: parseFloat(g),
      chunks: L || 1,
      max_price_change: 0.5
    };
    try {
      const { data: t } = await A.post("/stoploss/estimate", s, {
        signal: o
      });
      t.splits = [], t.expected_output = t.expected_output_without_slippage || 0, _(t), r(""), y(F(t.total_output));
    } catch (t) {
      if (console.log(t), t.name === "AbortError")
        return !0;
      ((p = t.response) == null ? void 0 : p.data) === "pool_out_of_sync" && r("Pools Out Of Sync"), ((n = t.response) == null ? void 0 : n.data) === "not_enough_liquidity" && r("Not Enough Liquidity"), ((m = t.response) == null ? void 0 : m.data) === "pool_not_found" && r("Pool Not Found"), ((u = t.response) == null ? void 0 : u.data) === "input_too_small" && r("Input Too Small");
    } finally {
      i(!1);
    }
    return !0;
  } };
};
export {
  R as useEstimateStopLoss
};
