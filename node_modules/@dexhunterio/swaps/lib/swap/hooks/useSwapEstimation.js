import A from "../../store/useStore.js";
import { server as S } from "../../config/axios.js";
import { roundNumber as L, getBonusOutput as N } from "../../utils/formatNumber.js";
import "react";
import "../../_commonjsHelpers-10dfc225.js";
import "../../index-9d43cc8b.js";
import "../../store/createTokenSearchSlice.js";
import "../../immer-548168ec.js";
import "../../store/createWalletSlice.js";
import "../../store/createSwapSettingsSlice.js";
import "../../store/createGlobalSettingsSlice.js";
import "../../store/createUserOrdersSlice.js";
import "../../store/createSwapSlice.js";
import "../../store/createChartSlice.js";
import "../../store/createBasketSlice.js";
import "../components/tokens.js";
import "../../store/createModalWhatsNewSlice.js";
import "../../store/createSwapParamsSlice.js";
import "../../index-ca8eb9e1.js";
import "../../axios-ddd885c5.js";
import "../../config/decrypt.js";
const rt = () => {
  const {
    tokenSell: t,
    tokenBuy: i,
    sellAmount: s,
    setIsTokenPriceLoading: g,
    setSwapDetails: d,
    setTokenPrice: w,
    setIsSwapDetailsLoading: y,
    setEstimationError: r,
    isTransactionLoading: T,
    inputMode: l,
    buyAmount: m,
    dexBlacklist: h,
    setBuyAmount: E,
    setSellAmount: P,
    setBonusOutput: I
  } = A((e) => e.swapSlice), { slippage: R } = A((e) => e.swapSettingsSlice), { defaultBuySize: U, partnerCode: $, partnerName: v } = A((e) => e.globalSettingsSlice);
  return { estimateSwap: async ({ signal: e, newTokenSell: _, newTokenBuy: b }) => {
    var p, c, f, D, k, F;
    if (T)
      return !0;
    g(!0), y(!0);
    let n = h;
    ((i == null ? void 0 : i.token_id) === "8a1cfae21368b8bebbbed9800fec304e95cce39a2a57dc35e2e3ebaa4d494c4b" || (t == null ? void 0 : t.token_id) === "8a1cfae21368b8bebbbed9800fec304e95cce39a2a57dc35e2e3ebaa4d494c4b") && ((t == null ? void 0 : t.token_id) === "" && s <= 500 && (n = ["WINGRIDER", "SUNDAESWAP", "SPECTRUM", "VYFI"]), (t == null ? void 0 : t.token_id) === "8a1cfae21368b8bebbbed9800fec304e95cce39a2a57dc35e2e3ebaa4d494c4b" && s <= 50 && (n = ["WINGRIDER", "SUNDAESWAP", "SPECTRUM", "VYFI"]));
    const u = {
      token_in: (p = _ || t) == null ? void 0 : p.token_id,
      token_out: (c = b || i) == null ? void 0 : c.token_id,
      slippage: R,
      blacklisted_dexes: n,
      referrer: v
    };
    try {
      if (l === "SELL" && s && parseFloat(s) > 0) {
        const o = {
          amount_in: parseFloat(s || U),
          ...u
        }, { data: a } = await S.post("/v2/swap/estimate", o, {
          signal: e,
          headers: {
            "X-Partner-Id": $
          }
        });
        return delete a.total_input, d(a), r(""), E(L(a.total_output_without_slippage)), I(`+${N(a.possible_routes)} ${i == null ? void 0 : i.ticker}`), !0;
      }
      if (l === "BUY" && m && parseFloat(m) > 0) {
        const o = {
          amount_out: parseFloat(m),
          ...u,
          slippage: 0
        }, { data: a } = await S.post("/v2/swap/reverseEstimate", o, {
          signal: e
        });
        return delete a.total_output_without_slippage, d(a), r(""), P(L(a.total_input)), I(`+${N(a.possible_routes)} ${t == null ? void 0 : t.ticker}`), !0;
      }
      parseFloat(s) === 0 && l === "SELL" && (d(null), E(0)), parseFloat(m) === 0 && l === "BUY" && (d(null), P(0)), r("");
    } catch (o) {
      if (console.log(o), o.name === "AbortError")
        return !0;
      ((f = o.response) == null ? void 0 : f.data) === "pool_out_of_sync" && r("Pools Out Of Sync"), ((D = o.response) == null ? void 0 : D.data) === "not_enough_liquidity" && r("Not Enough Liquidity"), ((k = o.response) == null ? void 0 : k.data) === "pool_not_found" && r("Pool Not Found"), ((F = o.response) == null ? void 0 : F.data) === "input_too_small" && r("Input Too Small");
    } finally {
      y(!1);
    }
    return !0;
  }, estimatePrice: async ({ signal: e, newTokenSell: _, newTokenBuy: b }) => {
    var n, u;
    try {
      const p = ((n = _ || t) == null ? void 0 : n.token_id) || "ADA", c = ((u = b || i) == null ? void 0 : u.token_id) || "ADA";
      if (p === "ADA" && c === "ADA")
        return !0;
      const { data: f } = await S.get(
        `/swap/averagePrice/${p}/${c}`,
        { signal: e }
      );
      w(f);
    } catch {
      w(0);
    } finally {
      g(!1);
    }
    return !0;
  } };
};
export {
  rt as useEstimateSwap
};
