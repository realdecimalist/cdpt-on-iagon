import m from "../../store/useStore.js";
import { server as f } from "../../config/axios.js";
import { useNotify as q } from "../../hooks/useNotify.js";
import { findHighestLiquidity as B } from "../../utils/formatToken.js";
import { CARDANO_TOKEN_IDENTIFIER as L } from "../components/tokens.js";
import { a as H } from "../../axios-ddd885c5.js";
import "react";
import "../../_commonjsHelpers-10dfc225.js";
import "../../index-9d43cc8b.js";
import "../../store/createTokenSearchSlice.js";
import "../../immer-548168ec.js";
import "../../store/createWalletSlice.js";
import "../../store/createSwapSettingsSlice.js";
import "../../store/createGlobalSettingsSlice.js";
import "../../store/createUserOrdersSlice.js";
import "../../store/createSwapSlice.js";
import "../../store/createChartSlice.js";
import "../../store/createBasketSlice.js";
import "../../store/createModalWhatsNewSlice.js";
import "../../store/createSwapParamsSlice.js";
import "../../index-ca8eb9e1.js";
import "../../config/decrypt.js";
import "react/jsx-runtime";
import "../../react-toastify.esm-a636d9b1.js";
import "../../assets/svg/IconCopy.js";
import "../../assets/svg/IconX.js";
import "../../assets/svg/IconCheckNotify.js";
import "../../assets/svg/IconAlertTriangleNotify.js";
import "../../assets/svg/IconArrowUpRightNotify.js";
import "../../lib.js";
import "../../extend-tailwind-merge-e63b2b56.js";
import "../../hooks/useScreen.js";
const Ot = () => {
  const { notify: g } = q(), {
    tokenBuy: a,
    tokenSell: o,
    sellAmount: b,
    setIsTransactionLoading: l,
    estimationError: S,
    dexBlacklist: N,
    setBuyAmount: E,
    setSellAmount: F,
    setSwapDetails: P,
    swapDetails: i,
    limitPrice: w,
    limitMultiples: x,
    setLimitMultiples: v,
    setIsSwapSubmitted: M,
    onViewOrder: y
  } = m((t) => t.swapSlice), {
    api: n,
    userAddress: h,
    balance: U
  } = m((t) => t.walletSlice), { poolInfo: V } = m((t) => t.chartSlice), {
    setUpcomingOrders: X,
    setPendingOrdersCount: K,
    pendingOrdersCount: z
  } = m((t) => t.userOrdersSlice), { partnerCode: D, partnerName: R } = m((t) => t.globalSettingsSlice), d = () => {
    const t = (i.total_fee + i.partner_fee) / 1e6, p = parseFloat(b);
    return p + t > U && (o == null ? void 0 : o.token_id) === "" ? parseFloat(p - t) : parseFloat(p);
  };
  return { limitToken: async () => {
    var p, T, I, k, A, O;
    if (l(!0), b === 0 || S) {
      l(!1);
      return;
    }
    let t = {
      sign: null,
      tx: "",
      err: null,
      step: "pre-swap",
      payload: null
    };
    try {
      const r = B(V), C = {
        buyer_address: h,
        token_in: o == null ? void 0 : o.token_id,
        token_out: (a == null ? void 0 : a.token_id) || "",
        amount_in: d(),
        blacklisted_dexes: N,
        wanted_price: parseFloat(w),
        to_split: !(r != null && r.dexName),
        multiples: x,
        dex: r == null ? void 0 : r.dexName,
        referrer: R
      };
      t.payload = C;
      const { data: u } = await f.post("/swap/limit", C, {
        headers: {
          "X-Partner-Id": D
        }
      });
      t.swap = u, t.step = "pre-sign";
      const Y = await (n == null ? void 0 : n.signTx(u.cbor, !0)), { data: s } = await f.post("/swap/sign", {
        txCbor: u.cbor,
        signatures: Y
      });
      t.sign = s, t.step = "pre-submit";
      const c = await (n == null ? void 0 : n.submitTx(s.cbor));
      t.tx = c, t.step = "after-submit";
      try {
        await f.post("/marking/submit", {
          tx_hash: c,
          order_type: "LIMIT"
        });
      } catch (e) {
        console.log(e), t.marking_err = ((p = e == null ? void 0 : e.response) == null ? void 0 : p.data) || (e == null ? void 0 : e.message) || (e == null ? void 0 : e.info);
      }
      if (s != null && s.strat_id)
        try {
          await H.put("https://api.axo.trade/notify", {
            tx_id: c,
            strat_id: s == null ? void 0 : s.strat_id
          }, { headers: { "X-Api-Key": "zIXsxTvPrmu7VstLXf2UvAZVTf64zK9t" } });
        } catch (e) {
          console.log(e), t.marking_err = ((T = e == null ? void 0 : e.response) == null ? void 0 : T.data) || (e == null ? void 0 : e.message) || (e == null ? void 0 : e.info);
        }
      const _ = i == null ? void 0 : i.splits.map((e) => ({
        ...e,
        tx_hash: c,
        status: "SUBMITTED",
        amount_in: d(),
        token_id_in: (o == null ? void 0 : o.token_id) || L,
        token_id_out: (a == null ? void 0 : a.token_id) || L,
        expected_out_amount: d() / parseFloat(w),
        submission_time: (/* @__PURE__ */ new Date()).toISOString(),
        user_address: h,
        upcoming: !0,
        type: (o == null ? void 0 : o.token_id) === "" ? "BUY" : "SELL"
      }));
      M(!0), g({
        type: "success",
        title: "Order placed",
        desc: "Your order has been placed successfully",
        actionName: "View order",
        dataCallback: _,
        actionCallback: () => {
          if (y) {
            y(_);
            return;
          }
          console.log("callback");
        }
      }), X(_), K(z + (x || ((I = i == null ? void 0 : i.splits) == null ? void 0 : I.length))), F(0), E(0), v(0), P(null);
    } catch (r) {
      if (console.log(r), console.log(r.message), t.err = ((k = r.response) == null ? void 0 : k.data) || r.message || r.info, (A = r.message) != null && A.toLowerCase().includes("declined") || (O = r.info) != null && O.toLowerCase().includes("declined"))
        return;
      g({
        type: "error",
        title: "Error placing order",
        desc: "There was an error placing your order",
        actionCallback: () => {
          navigator.clipboard.writeText(JSON.stringify(t));
        }
      });
    } finally {
      l(!1);
    }
  } };
};
export {
  Ot as useLimitAction
};
